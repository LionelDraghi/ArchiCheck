<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - ArchiCheck tests coverage - /home/lionel/Proj/Archicheck/Src/archicheck-rules_parser.adb</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">home/lionel/Proj/Archicheck/Src</a> - archicheck-rules_parser.adb<span style="font-size: 80%;"> (source / <a href="archicheck-rules_parser.adb.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">ArchiCheck tests coverage</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">131</td>
            <td class="headerCovTableEntry">172</td>
            <td class="headerCovTableEntryMed">76.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-11-30 23:30:31</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">19</td>
            <td class="headerCovTableEntry">45</td>
            <td class="headerCovTableEntryLo">42.2 %</td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : -- -----------------------------------------------------------------------------</a>
<span class="lineNum">       2 </span>            : -- ArchiCheck, the software architecture compliance verifier
<span class="lineNum">       3 </span>            : -- Copyright (C) 2005, 2006, 2009 - Lionel Draghi
<span class="lineNum">       4 </span>            : -- This program is free software;
<span class="lineNum">       5 </span>            : -- you can redistribute it and/or modify it under the terms of the GNU General
<span class="lineNum">       6 </span>            : -- Public License Versions 3, refer to the COPYING file.
<span class="lineNum">       7 </span>            : -- -----------------------------------------------------------------------------
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : -- -----------------------------------------------------------------------------
<span class="lineNum">      10 </span>            : -- Package: Archicheck.Rules_Parser body
<span class="lineNum">      11 </span>            : --
<span class="lineNum">      12 </span>            : -- Implementation Notes:
<span class="lineNum">      13 </span>            : --
<span class="lineNum">      14 </span>            : -- Portability Issues:
<span class="lineNum">      15 </span>            : --
<span class="lineNum">      16 </span>            : -- Anticipated Changes:
<span class="lineNum">      17 </span>            : -- -----------------------------------------------------------------------------
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : with OpenToken.Token; use OpenToken.Token;
<span class="lineNum">      20 </span>            : with OpenToken.Text_Feeder.Text_IO;
<span class="lineNum">      21 </span>            : with OpenToken.Text_Feeder;
<span class="lineNum">      22 </span>            : with OpenToken.Token.Enumerated;
<span class="lineNum">      23 </span>            : with OpenToken.Token.Enumerated.Identifier;
<span class="lineNum">      24 </span>            : with OpenToken.Token.Enumerated.Analyzer;
<span class="lineNum">      25 </span>            : with OpenToken.Recognizer.Identifier;
<span class="lineNum">      26 </span>            : with OpenToken.Recognizer.Character_Set;
<span class="lineNum">      27 </span>            : with OpenToken.Recognizer.Separator;
<span class="lineNum">      28 </span>            : -- with OpenToken.Recognizer.Line_Comment;
<span class="lineNum">      29 </span>            : with OpenToken.Production.List;
<span class="lineNum">      30 </span>            : with OpenToken.Production.Parser.LALR.Generator;
<span class="lineNum">      31 </span>            : with OpenToken.Production.Parser.LALR.Parser;
<span class="lineNum">      32 </span>            : with OpenToken.Production.Parser.LALR.Parser_Lists;
<span class="lineNum">      33 </span>            : with OpenToken.Recognizer.End_Of_File;
<span class="lineNum">      34 </span>            : with OpenToken.Token.Enumerated.List;
<span class="lineNum">      35 </span>            : with OpenToken.Token.Enumerated.Nonterminal;
<span class="lineNum">      36 </span>            : with OpenToken.Recognizer.Keyword;
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : with Archicheck.IO;
<span class="lineNum">      39 </span>            : with Archicheck.Settings;
<span class="lineNum">      40 </span>            : with Archicheck.Components;   use Archicheck.Components;
<span class="lineNum">      41 </span>            : with Archicheck.Layers;
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : with Ada.Exceptions;
<span class="lineNum">      44 </span>            : with Ada.Text_IO;
<span class="lineNum">      45 </span>            : with Ada.Strings.Maps.Constants;
<span class="lineNum">      46 </span>            : with Ada.Strings.Unbounded;
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span><span class="lineCov">        672 : package body Archicheck.Rules_Parser is</span>
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            :    -- Change default Debug parameter value to enable/disable Debug messages in this package
<span class="lineNum">      51 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">      52 </span>            :    procedure Put_Debug_Line (Msg    : in String  := &quot;&quot;;
<span class="lineNum">      53 </span>            :                              Debug  : in Boolean := False; -- change to True to debug this package
<span class="lineNum">      54 </span>            :                              Prefix : in String  := &quot;Rules_Parser&quot;) renames Archicheck.IO.Put_Debug_Line;
<span class="lineNum">      55 </span>            :    --     procedure Put_Debug (Msg    : in String  := &quot;&quot;;
<span class="lineNum">      56 </span>            :    --                          Debug  : in Boolean := True;
<span class="lineNum">      57 </span>            :    --                          Prefix : in String  := &quot;Rules_Parser&quot;) renames Archicheck.IO.Put_Debug;
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :    -- The list of tokens, without non-terminals in recursive descent.
<span class="lineNum">      61 </span>            :    type Token_Ids is
<span class="lineNum">      62 </span>            :      (-- Non reporting tokens (not used in generating an LALR grammar) -----------------------------------------
<span class="lineNum">      63 </span>            :       Whitespace_Id,
<span class="lineNum">      64 </span>            :       -- Comment_Id,
<span class="lineNum">      65 </span>            :       --        EoL_Id,
<span class="lineNum">      66 </span>            :       --        Minus_Id,
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            :       -- Terminals tokens ---------------
<span class="lineNum">      69 </span>            :       -- Keywords
<span class="lineNum">      70 </span>            :       A_Id, -- first terminal
<span class="lineNum">      71 </span>            :       And_Id,
<span class="lineNum">      72 </span>            :       Contains_Id,
<span class="lineNum">      73 </span>            :       Is_Id,
<span class="lineNum">      74 </span>            :       Layer_Id,
<span class="lineNum">      75 </span>            :       Only_Id,
<span class="lineNum">      76 </span>            :       May_Id,
<span class="lineNum">      77 </span>            :       Over_Id,
<span class="lineNum">      78 </span>            :       Use_Id,
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :       -- Misc
<span class="lineNum">      81 </span>            :       Comma_Id, -- ,
<span class="lineNum">      82 </span>            :       Dot_Id, -- .
<span class="lineNum">      83 </span>            :       Semicolon_Id, -- ;
<span class="lineNum">      84 </span>            :       EoF_Id,
<span class="lineNum">      85 </span>            :       -- Whitespace_Id,
<span class="lineNum">      86 </span>            :       -- Comment_Id,
<span class="lineNum">      87 </span>            :       --        EoL_Id,
<span class="lineNum">      88 </span>            :       --        Minus_Id,
<span class="lineNum">      89 </span>            :       --  Identifier must be after keywords, so they are recognized instead
<span class="lineNum">      90 </span>            :       Identifier_Id, -- last terminal
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :       -- Non-terminals tokens ---------------
<span class="lineNum">      93 </span>            :       Rules_File_Id,
<span class="lineNum">      94 </span>            :       Rule_List_Id,
<span class="lineNum">      95 </span>            :       Rule_Id,
<span class="lineNum">      96 </span>            :       Unit_List_Id,
<span class="lineNum">      97 </span>            :       Component_Declaration_Id,
<span class="lineNum">      98 </span>            :       Layer_Declaration_Id,
<span class="lineNum">      99 </span>            :       Use_Declaration_Id,
<span class="lineNum">     100 </span>            :       Use_Restriction_Declaration_Id
<span class="lineNum">     101 </span>            :      );
<span class="lineNum">     102 </span>            :    First_Terminal : constant Token_Ids := A_Id;
<span class="lineNum">     103 </span>            :    Last_Terminal  : constant Token_Ids := Identifier_Id;
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            :    -- private
<a name="106"><span class="lineNum">     106 </span>            : </a>
<span class="lineNum">     107 </span>            :    package Master_Token is new OpenToken.Token.Enumerated
<span class="lineNum">     108 </span><span class="lineCov">         16 :      (Token_Ids, First_Terminal, Last_Terminal, Token_Ids'Image);</span>
<span class="lineNum">     109 </span>            :    package Tokenizer is new Master_Token.Analyzer;
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :    package Token_List is new Master_Token.List;
<span class="lineNum">     112 </span>            :    package Nonterminal is new Master_Token.Nonterminal (Token_List);
<span class="lineNum">     113 </span>            :    package Identifiers is new Master_Token.Identifier;
<span class="lineNum">     114 </span>            :    package Production is new OpenToken.Production (Master_Token, Token_List, Nonterminal);
<span class="lineNum">     115 </span>            :    package Production_List is new Production.List;
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :    package Parser is new Production.Parser (Tokenizer);
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            :    package LALRs is new Parser.LALR (First_State_Index =&gt; 1);
<span class="lineNum">     120 </span>            :    First_Parser_Label : constant := 1;
<span class="lineNum">     121 </span>            :    package Parser_Lists is new LALRs.Parser_Lists (First_Parser_Label);
<span class="lineNum">     122 </span>            :    package LALR_Parser is new LALRs.Parser (First_Parser_Label, Parser_Lists);
<span class="lineNum">     123 </span>            :    Token_Image_Width : constant Integer := Token_Ids'Width;
<span class="lineNum">     124 </span>            :    package LALR_Generator is new LALRs.Generator (Token_Image_Width, Production_List);
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            :    -- Step 3: Map the Terminal Token ID's to their recognizers and tokens
<span class="lineNum">     128 </span><span class="lineCov">       3808 :    Syntax : constant Tokenizer.Syntax :=</span>
<span class="lineNum">     129 </span><span class="lineCov">       1568 :               (Whitespace_Id =&gt; Tokenizer.Get (OpenToken.Recognizer.Character_Set.Get (OpenToken.Recognizer.Character_Set.Standard_Whitespace)),</span>
<span class="lineNum">     130 </span>            :                -- Comment_Id    =&gt; Tokenizer.Get (OpenToken.Recognizer.Line_Comment.Get (&quot;--&quot;, Reportable =&gt; True)), --** que veut dire le reportable??
<span class="lineNum">     131 </span>            :                --
<span class="lineNum">     132 </span><span class="lineCov">       1120 :                A_Id          =&gt; Tokenizer.Get (OpenToken.Recognizer.Keyword.Get (&quot;a&quot;)),</span>
<span class="lineNum">     133 </span><span class="lineCov">       1120 :                And_Id        =&gt; Tokenizer.Get (OpenToken.Recognizer.Keyword.Get (&quot;and&quot;)),</span>
<span class="lineNum">     134 </span><span class="lineCov">       1120 :                Contains_Id   =&gt; Tokenizer.Get (OpenToken.Recognizer.Keyword.Get (&quot;contains&quot;)),</span>
<span class="lineNum">     135 </span><span class="lineCov">       1120 :                Is_Id         =&gt; Tokenizer.Get (OpenToken.Recognizer.Keyword.Get (&quot;is&quot;)),</span>
<span class="lineNum">     136 </span><span class="lineCov">       1120 :                Layer_Id      =&gt; Tokenizer.Get (OpenToken.Recognizer.Keyword.Get (&quot;layer&quot;)),</span>
<span class="lineNum">     137 </span><span class="lineCov">       1120 :                Only_Id       =&gt; Tokenizer.Get (OpenToken.Recognizer.Keyword.Get (&quot;only&quot;)),</span>
<span class="lineNum">     138 </span><span class="lineCov">       1120 :                May_Id        =&gt; Tokenizer.Get (OpenToken.Recognizer.Keyword.Get (&quot;may&quot;)),</span>
<span class="lineNum">     139 </span><span class="lineCov">       1120 :                Over_Id       =&gt; Tokenizer.Get (OpenToken.Recognizer.Keyword.Get (&quot;over&quot;)),</span>
<span class="lineNum">     140 </span><span class="lineCov">       1120 :                Use_Id        =&gt; Tokenizer.Get (OpenToken.Recognizer.Keyword.Get (&quot;use&quot;)),</span>
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            :                -- Delimiters
<span class="lineNum">     143 </span>            :                -- Comment_Id    =&gt; Tokenizer.Get (OpenToken.Recognizer.Line_Comment.Get (&quot;--&quot;, Reportable =&gt; True)), --** que veut dire le reportable??
<span class="lineNum">     144 </span><span class="lineCov">       1120 :                Comma_Id      =&gt; Tokenizer.Get (OpenToken.Recognizer.Separator.Get (&quot;,&quot;)),</span>
<span class="lineNum">     145 </span>            :                -- Whitespace_Id =&gt; Tokenizer.Get (OpenToken.Recognizer.Character_Set.Get (OpenToken.Recognizer.Character_Set.Standard_Whitespace)),
<span class="lineNum">     146 </span><span class="lineCov">       1120 :                Dot_Id        =&gt; Tokenizer.Get (OpenToken.Recognizer.Separator.Get (&quot;.&quot;)),</span>
<span class="lineNum">     147 </span>            :                -- Minus_Id      =&gt; Tokenizer.Get (OpenToken.Recognizer.Separator.Get (&quot;-&quot;)),
<span class="lineNum">     148 </span><span class="lineCov">       1120 :                Semicolon_Id  =&gt; Tokenizer.Get (OpenToken.Recognizer.Separator.Get (&quot;;&quot;)),</span>
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span><span class="lineCov">       1120 :                EoF_Id        =&gt; Tokenizer.Get (OpenToken.Recognizer.End_Of_File.Get),</span>
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :                --  Identifier must be after keywords, so they are recognized instead
<span class="lineNum">     153 </span><span class="lineCov">        448 :                Identifier_Id =&gt; Tokenizer.Get</span>
<span class="lineNum">     154 </span><span class="lineCov">        224 :                  (Recognizer =&gt; OpenToken.Recognizer.Identifier.Get</span>
<span class="lineNum">     155 </span>            :                     (Start_Chars =&gt; Ada.Strings.Maps.Constants.Letter_Set,
<span class="lineNum">     156 </span>            :                      Body_Chars  =&gt; Ada.Strings.Maps.Constants.Alphanumeric_Set),
<span class="lineNum">     157 </span><span class="lineCov">       1120 :                   New_Token  =&gt; Identifiers.Get (Identifier_Id))</span>
<span class="lineNum">     158 </span>            :                --
<span class="lineNum">     159 </span>            :                -- EoL_Id        =&gt; Tokenizer.Get (OpenToken.Recognizer.Separator.Get ((1 =&gt; OpenToken.EOL_Character))),
<span class="lineNum">     160 </span>            :                -- Bad_Token_Id  =&gt; Tokenizer.Get (OpenToken.Recognizer.Nothing.Get),
<span class="lineNum">     161 </span>            :                 );
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            :    --  The non-terminal tokens are pointers (type Handle) to allow for
<span class="lineNum">     164 </span>            :    --  mutual recursion. So the terminal ones are too, for
<span class="lineNum">     165 </span>            :    --  consistency, and to reduce the number of '&amp;' and 'or' operators
<span class="lineNum">     166 </span>            :    --  we need.
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            :    --  Terminal tokens
<span class="lineNum">     170 </span><span class="lineCov">       1344 :    A_T          : constant Master_Token.Class := Master_Token.Get (A_Id);</span>
<span class="lineNum">     171 </span><span class="lineCov">       1344 :    And_T        : constant Master_Token.Class := Master_Token.Get (And_Id);</span>
<span class="lineNum">     172 </span><span class="lineCov">       1344 :    Contains_T   : constant Master_Token.Class := Master_Token.Get (Contains_Id);</span>
<span class="lineNum">     173 </span><span class="lineCov">       1344 :    Comma_T      : constant Master_Token.Class := Master_Token.Get (Comma_Id);</span>
<span class="lineNum">     174 </span><span class="lineCov">       1344 :    Dot_T        : constant Master_Token.Class := Master_Token.Get (Dot_Id);</span>
<span class="lineNum">     175 </span><span class="lineCov">       1344 :    Identifier_T : constant Master_Token.Class := Master_Token.Get (Identifier_Id);</span>
<span class="lineNum">     176 </span><span class="lineCov">       1344 :    Is_T         : constant Master_Token.Class := Master_Token.Get (Is_Id);</span>
<span class="lineNum">     177 </span><span class="lineCov">       1344 :    EoF_T        : constant Master_Token.Class := Master_Token.Get (EoF_Id);</span>
<span class="lineNum">     178 </span>            :    -- EoL       : constant Master_Token.Class := Master_Token.Get (EoL_Id);
<span class="lineNum">     179 </span><span class="lineCov">       1344 :    Layer_T      : constant Master_Token.Class := Master_Token.Get (Layer_Id);</span>
<span class="lineNum">     180 </span><span class="lineCov">       1344 :    Only_T       : constant Master_Token.Class := Master_Token.Get (Only_Id);</span>
<span class="lineNum">     181 </span><span class="lineCov">       1344 :    May_T        : constant Master_Token.Class := Master_Token.Get (May_Id);</span>
<span class="lineNum">     182 </span><span class="lineCov">       1344 :    Use_T        : constant Master_Token.Class := Master_Token.Get (Use_Id);</span>
<span class="lineNum">     183 </span><span class="lineCov">       1344 :    Over_T       : constant Master_Token.Class := Master_Token.Get (Over_Id);</span>
<span class="lineNum">     184 </span><span class="lineCov">       1344 :    Semicolon_T  : constant Master_Token.Class := Master_Token.Get (Semicolon_Id);</span>
<span class="lineNum">     185 </span>            :    -- Comment_T   : constant Master_Token.Class := Master_Token.Get (Comment_Id);
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            :    -- Non-terminal tokens, which define the grammar.
<span class="lineNum">     188 </span><span class="lineCov">       1344 :    Use_Declaration             : constant Nonterminal.Class := Nonterminal.Get (Use_Declaration_Id);</span>
<span class="lineNum">     189 </span><span class="lineCov">       1344 :    Use_Restriction_Declaration : constant Nonterminal.Class := Nonterminal.Get (Use_Restriction_Declaration_Id);</span>
<span class="lineNum">     190 </span><span class="lineCov">       1344 :    Layer_Declaration           : constant Nonterminal.Class := Nonterminal.Get (Layer_Declaration_Id);</span>
<span class="lineNum">     191 </span><span class="lineCov">       1344 :    Component_Declaration       : constant Nonterminal.Class := Nonterminal.Get (Component_Declaration_Id);</span>
<span class="lineNum">     192 </span><span class="lineCov">       1344 :    Rule                        : constant Nonterminal.Class := Nonterminal.Get (Rule_Id);</span>
<span class="lineNum">     193 </span><span class="lineCov">       1344 :    Rule_List                   : constant Nonterminal.Class := Nonterminal.Get (Rule_List_Id);</span>
<span class="lineNum">     194 </span><span class="lineCov">       1344 :    Rules_File                  : constant Nonterminal.Class := Nonterminal.Get (Rules_File_Id);</span>
<span class="lineNum">     195 </span><span class="lineCov">       1344 :    Unit_List                   : constant Nonterminal.Class := Nonterminal.Get (Unit_List_Id);</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            :    --  Allow infix operators for building productions
<span class="lineNum">     198 </span>            :    use type Token_List.Instance;
<span class="lineNum">     199 </span>            :    use type Production.Right_Hand_Side;
<span class="lineNum">     200 </span>            :    use type Production.Instance;
<span class="lineNum">     201 </span>            :    use type Production_List.Instance;
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     205 </span>            :    procedure Store_Component_Declaration (New_Token : out Nonterminal.Class;
<span class="lineNum">     206 </span>            :                                           Source    : in  Token_List.Instance'Class;
<span class="lineNum">     207 </span>            :                                           To_ID     : in  Master_Token.Token_ID);
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     210 </span>            :    procedure Store_Layer_Declaration (New_Token : out Nonterminal.Class;
<span class="lineNum">     211 </span>            :                                       Source    : in  Token_List.Instance'Class;
<span class="lineNum">     212 </span>            :                                       To_ID     : in  Master_Token.Token_ID);
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     215 </span>            :    procedure Store_Use_Declaration (New_Token : out Nonterminal.Class;
<span class="lineNum">     216 </span>            :                                     Source    : in  Token_List.Instance'Class;
<span class="lineNum">     217 </span>            :                                     To_ID     : in  Master_Token.Token_ID);
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     220 </span>            :    procedure Store_Use_Restriction_Declaration (New_Token : out Nonterminal.Class;
<span class="lineNum">     221 </span>            :                                                 Source    : in  Token_List.Instance'Class;
<span class="lineNum">     222 </span>            :                                                 To_ID     : in  Master_Token.Token_ID);
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     225 </span>            :    procedure Initialize_Unit_List (New_Token : out Nonterminal.Class;
<span class="lineNum">     226 </span>            :                                    Source    : in  Token_List.Instance'Class;
<span class="lineNum">     227 </span>            :                                    To_ID     : in  Master_Token.Token_ID);
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     230 </span>            :    procedure Append_Unit_To_List (New_Token : out Nonterminal.Class;
<span class="lineNum">     231 </span>            :                                   Source    : in  Token_List.Instance'Class;
<span class="lineNum">     232 </span>            :                                   To_ID     : in  Master_Token.Token_ID);
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            :    -- Grammar:
<span class="lineNum">     235 </span>            :    --
<span class="lineNum">     236 </span>            :    -- Rules_File                  -&gt; Rule_List &amp; EoF
<span class="lineNum">     237 </span>            :    -- Rule_List                   -&gt; Rule [Rule]*
<span class="lineNum">     238 </span>            :    -- Separator                   -&gt; , | and | blank
<span class="lineNum">     239 </span>            :    -- Unit_List                   -&gt; Unit [[Separator]* Unit]*                    Unit_List = Unit &amp; Unit &amp; Unit etc.
<span class="lineNum">     240 </span>            :    -- Component_Declaration       -&gt; Component contains Unit_List                 Insert [Component, Unit_List] in Component_List
<span class="lineNum">     241 </span>            :    -- Layer_Declaration           -&gt; Layer is a layer over Layer                  Insert [Layer, Layer]         in Layer_List
<span class="lineNum">     242 </span>            :    -- Use_Restriction_Declaration -&gt; only Component1 may use component2
<span class="lineNum">     243 </span>            :    -- Use_Declaration             -&gt; Component1 uses Component2
<span class="lineNum">     244 </span>            :    -- Rule                        -&gt; Component_Declaration | Layer_Declaration | Use_Declaration | Use_Restriction_Declaration
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineCov">        448 :    Grammar : constant Production_List.Instance :=</span>
<span class="lineNum">     247 </span><span class="lineCov">        224 :                Rules_File                  &lt;= Rule_List &amp; EoF_T                  and</span>
<span class="lineNum">     248 </span><span class="lineCov">        448 :                Rule_List                   &lt;= Rule_List &amp; Semicolon_T            and</span>
<span class="lineNum">     249 </span><span class="lineCov">        448 :                Rule_List                   &lt;= Rule_List &amp; Dot_T                  and</span>
<span class="lineNum">     250 </span><span class="lineCov">        448 :                Rule_List                   &lt;= Rule_List &amp; Rule                   and</span>
<span class="lineNum">     251 </span><span class="lineCov">        448 :                Rule_List                   &lt;= Rule                               and</span>
<span class="lineNum">     252 </span>            :                -- Rule                   &lt;= Comment_T                          and
<span class="lineNum">     253 </span><span class="lineCov">        448 :                Rule                        &lt;= Use_Declaration                    and</span>
<span class="lineNum">     254 </span><span class="lineCov">        448 :                Rule                        &lt;= Use_Restriction_Declaration        and</span>
<span class="lineNum">     255 </span><span class="lineCov">        448 :                Rule                        &lt;= Layer_Declaration                  and</span>
<span class="lineNum">     256 </span><span class="lineCov">        448 :                Rule                        &lt;= Component_Declaration              and</span>
<span class="lineNum">     257 </span><span class="lineCov">        448 :                Unit_List                   &lt;= Identifier_T &amp; Comma_T &amp; Unit_List                          + Append_Unit_To_List'Access         and</span>
<span class="lineNum">     258 </span><span class="lineCov">        448 :                Unit_List                   &lt;= Identifier_T &amp; And_T   &amp; Unit_List                          + Append_Unit_To_List'Access         and</span>
<span class="lineNum">     259 </span>            :                -- Unit_List              &lt;= Identifier           &amp; Unit_List                    + Append_Unit_To_List'Access         and
<span class="lineNum">     260 </span><span class="lineCov">        448 :                Unit_List                   &lt;= Identifier_T                                                + Initialize_Unit_List'Access        and</span>
<span class="lineNum">     261 </span><span class="lineCov">        448 :                Component_Declaration       &lt;= Identifier_T &amp; Contains_T &amp; Unit_List                       + Store_Component_Declaration'Access and</span>
<span class="lineNum">     262 </span><span class="lineCov">        448 :                Layer_Declaration           &lt;= Identifier_T &amp; Is_T &amp; A_T &amp; Layer_T &amp; Over_T &amp; Identifier_T + Store_Layer_Declaration'Access     and</span>
<span class="lineNum">     263 </span><span class="lineCov">        448 :                Use_Declaration             &lt;= Identifier_T &amp; Use_T &amp; Identifier_T                         + Store_Use_Declaration'Access       and</span>
<span class="lineNum">     264 </span><span class="lineCov">        224 :                Use_Restriction_Declaration &lt;= Only_T &amp; Identifier_T &amp; May_T &amp; Use_T &amp; Identifier_T        + Store_Use_Restriction_Declaration'Access;</span>
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :    --  This is of type OpenToken.Token.Handle, so it can be passed to
<span class="lineNum">     267 </span>            :    --  OpenToken.Token.Parse, rather than Sequence.Parse.
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            :    -- Units_In_File definition : &quot;units in Dir1/*.ads&quot;
<span class="lineNum">     270 </span>            :    --     Units_In_File.all := Selection.Class
<span class="lineNum">     271 </span>            :    --       (File or
<span class="lineNum">     272 </span>            :    --        Sequence.New_Instance (File &amp; Selection.Class (And_T or Comma_T)));
<span class="lineNum">     273 </span>            :    -- File_List : File [(and|,) File]
<span class="lineNum">     274 </span>            :    -- example : units in Dir1/*.ads, units in Dir2 and units in Dir3&quot;
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            :    -- Step 5: Define the Lexical Analyser
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            :    --     type Sentence_Token is abstract new OpenToken.Token.Instance with null record;
<span class="lineNum">     280 </span>            :    --     --     function Could_Parse_To (Match    : in Instance;
<span class="lineNum">     281 </span>            :    --     --                              Analyzer : in Source_Class) return Boolean;
<span class="lineNum">     282 </span>            :    --
<span class="lineNum">     283 </span>            :    --     type Component_Definition_Token is abstract new OpenToken.Token.Instance with record
<span class="lineNum">     284 </span>            :    --        Component_Name : Ada.Strings.Unbounded.Unbounded_String;
<span class="lineNum">     285 </span>            :    --        Unit_List      : Unit_Lists.List;
<span class="lineNum">     286 </span>            :    --        Source_List    : Archicheck.Source_Lists.List;
<span class="lineNum">     287 </span>            :    --     end record;
<span class="lineNum">     288 </span>            :    --     type Component_Definition_Token_Handle is access all Component_Definition_Token'Class;
<span class="lineNum">     289 </span>            :    --
<span class="lineNum">     290 </span>            :    --     type Rule_Token is abstract new OpenToken.Token.Instance with record
<span class="lineNum">     291 </span>            :    --        Server_Name : Ada.Strings.Unbounded.Unbounded_String;
<span class="lineNum">     292 </span>            :    --        Client_Name : Ada.Strings.Unbounded.Unbounded_String;
<span class="lineNum">     293 </span>            :    --        --** pour l'instant seule la regle layer est traitée
<span class="lineNum">     294 </span>            :    --     end record;
<span class="lineNum">     295 </span>            :    --     type Rule_Token_Handle is access all Rule_Token'Class;
<span class="lineNum">     296 </span>            :    --
<span class="lineNum">     297 </span>            :    --     --     type File_List_Token is new OpenToken.Token.List.Instance with record
<span class="lineNum">     298 </span>            :    --     --        Source_List : Archicheck.Source_Lists.List;
<span class="lineNum">     299 </span>            :    --     --     end record; -- (File_List_Token, File_List_Token);
<span class="lineNum">     300 </span>            :    --     --     procedure Add_List_Element (Match   : in out File_List_Token;
<span class="lineNum">     301 </span>            :    --     --                                 Element : in out OpenToken.Token.Class);
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            :    --  Create a text feeder for our Input_File.
<span class="lineNum">     305 </span>            :    Input_File : aliased Ada.Text_IO.File_Type;
<span class="lineNum">     306 </span><span class="lineCov">        448 :    Feeder     : aliased OpenToken.Text_Feeder.Text_IO.Instance :=</span>
<span class="lineNum">     307 </span><span class="lineCov">        224 :                   OpenToken.Text_Feeder.Text_IO.Create (Input_File'Access);</span>
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span><span class="lineCov">        224 :    Analyzer   : constant Tokenizer.Handle := Tokenizer.Initialize (Syntax, Feeder'Access);</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :    --  The lalr parser instance.
<span class="lineNum">     312 </span><span class="lineCov">        448 :    Rules_File_Parser : LALR_Parser.Instance := LALR_Parser.Initialize</span>
<span class="lineNum">     313 </span>            :      (Analyzer,
<span class="lineNum">     314 </span><span class="lineCov">        224 :       LALR_Generator.Generate (Grammar, Ignore_Unused_Tokens =&gt; True)); --**</span>
<span class="lineNum">     315 </span><span class="lineCov">        672 :    Units             : Unit_Lists.List;</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     319 </span>            :    -- Procedure: Store_Component_Declaration
<span class="lineNum">     320 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     321 </span><span class="lineCov">        136 :    procedure Store_Component_Declaration (New_Token : out Nonterminal.Class;</span>
<span class="lineNum">     322 </span>            :                                           Source    : in  Token_List.Instance'Class;
<span class="lineNum">     323 </span>            :                                           To_ID     : in  Master_Token.Token_ID)
<span class="lineNum">     324 </span>            :    is
<span class="lineNum">     325 </span>            :       pragma Unreferenced (New_Token, To_ID);
<span class="lineNum">     326 </span><span class="lineCov">        136 :       Left  : constant Token_List.List_Iterator := Token_List.Initial_Iterator (Source);</span>
<span class="lineNum">     327 </span>            :       -- Right :          Token_List.List_Iterator := Token_List.Initial_Iterator (Source);
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :       use Archicheck.IO;
<span class="lineNum">     330 </span>            :       use OpenToken.Buffers;
<span class="lineNum">     331 </span>            :       use Ada.Strings.Unbounded;
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :    begin
<span class="lineNum">     334 </span>            :       -- Token_List.Next_Token (Right); -- move &quot;Right&quot; over &quot;contains&quot;
<span class="lineNum">     335 </span>            :       -- Token_List.Next_Token (Right); -- move &quot;Right&quot; over the Unit
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :       --** Token_List.Print (Source);
<a name="338"><span class="lineNum">     338 </span>            :       --** New_Line;</a>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span><span class="lineCov">        272 :       declare</span>
<span class="lineNum">     341 </span><span class="lineCov">        680 :          Component_Name : constant String := To_String (Identifiers.Instance (Token_List.Token_Handle (Left).all).Identifier);</span>
<span class="lineNum">     342 </span>            :          -- Unit_Name      : constant String := To_String (Identifiers.Instance (Token_List.Token_Handle (Right).all).Identifier);
<span class="lineNum">     343 </span><span class="lineCov">        136 :          Cursor         : Component_Maps.Cursor;</span>
<span class="lineNum">     344 </span><span class="lineCov">        136 :          Prefix         : constant String := GNU_Prefix (File   =&gt; Settings.Rules_File_Name,</span>
<span class="lineNum">     345 </span><span class="lineCov">        136 :                                                          Line   =&gt; Rules_File_Parser.Line,</span>
<span class="lineNum">     346 </span><span class="lineCov">        136 :                                                          Column =&gt; Rules_File_Parser.Column);</span>
<span class="lineNum">     347 </span>            :       begin
<a name="348"><span class="lineNum">     348 </span><span class="lineCov">        136 :          if Settings.List_Rules then</span></a>
<span class="lineNum">     349 </span><span class="lineCov">        280 :             for U of Units loop</span>
<span class="lineNum">     350 </span><span class="lineCov">        152 :               Put_Line (Prefix &amp; &quot;Component &quot; &amp; Component_Name &amp; &quot; contains Unit &quot; &amp; To_String (U));</span>
<span class="lineNum">     351 </span>            :             end loop;
<span class="lineNum">     352 </span>            :             -- Put_Line (Prefix &amp; &quot;Component &quot; &amp; Component_Name &amp; &quot; contains Unit &quot; &amp; Unit_List_Image (Units));
<span class="lineNum">     353 </span>            :          end if;
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span><span class="lineCov">        136 :          Cursor := Component_Maps.Find (Component_Map, Component_Name);</span>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineCov">        136 :          if Component_Maps.Has_Element (Cursor) then</span>
<span class="lineNum">     358 </span>            :             -- the component was described by one or more declarations
<span class="lineNum">     359 </span>            :             -- Units := Component_Maps.Element (Cursor);
<span class="lineNum">     360 </span>            :             -- Unit_Lists.Append (Units, To_Unbounded_String (Unit_Name));
<span class="lineNum">     361 </span><span class="lineCov">         24 :             Component_Maps.Replace_Element (Component_Map, Cursor, Units);</span>
<span class="lineNum">     362 </span><span class="lineCov">         24 :             Put_Debug_Line (&quot;Adding units &quot; &amp; Unit_List_Image (Units) &amp; &quot; to component &quot; &amp; Component_Name);</span>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            :          else
<span class="lineNum">     365 </span>            :             -- First occurence of this component
<span class="lineNum">     366 </span>            :             -- Unit_Lists.Append (Units, To_Unbounded_String (Unit_Name));
<span class="lineNum">     367 </span><span class="lineCov">        112 :             Component_Maps.Insert (Container =&gt; Component_Map,</span>
<span class="lineNum">     368 </span>            :                                    Key       =&gt; Component_Name,
<span class="lineNum">     369 </span>            :                                    New_Item  =&gt; Units);
<span class="lineNum">     370 </span><span class="lineCov">        112 :             Put_Debug_Line (&quot;Creating component &quot; &amp; Component_Name &amp; &quot;, adding units &quot; &amp; Unit_List_Image (Units));</span>
<span class="lineNum">     371 </span>            :          end if;
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineCov">        272 :       end;</span>
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span><span class="lineCov">        136 :    end Store_Component_Declaration;</span>
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     378 </span>            :    -- Procedure: Store_Layer_Declaration
<span class="lineNum">     379 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     380 </span><span class="lineCov">         88 :    procedure Store_Layer_Declaration (New_Token : out Nonterminal.Class;</span>
<span class="lineNum">     381 </span>            :                                       Source    : in  Token_List.Instance'Class;
<span class="lineNum">     382 </span>            :                                       To_ID     : in  Master_Token.Token_ID)
<span class="lineNum">     383 </span>            :    is
<span class="lineNum">     384 </span>            :       pragma Unreferenced (New_Token, To_ID);
<span class="lineNum">     385 </span><span class="lineCov">         88 :       Left  : constant Token_List.List_Iterator := Token_List.Initial_Iterator (Source);</span>
<span class="lineNum">     386 </span><span class="lineCov">         88 :       Right :          Token_List.List_Iterator := Token_List.Initial_Iterator (Source);</span>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            :       use Archicheck.IO;
<span class="lineNum">     389 </span>            :       use OpenToken.Buffers;
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            :    begin
<span class="lineNum">     392 </span><span class="lineCov">         88 :       Token_List.Next_Token (Right); -- move &quot;Right&quot; over &quot;is&quot;</span>
<span class="lineNum">     393 </span><span class="lineCov">         88 :       Token_List.Next_Token (Right); -- move &quot;Right&quot; over &quot;a&quot;</span>
<span class="lineNum">     394 </span><span class="lineCov">         88 :       Token_List.Next_Token (Right); -- move &quot;Right&quot; over &quot;layer&quot;</span>
<span class="lineNum">     395 </span><span class="lineCov">         88 :       Token_List.Next_Token (Right); -- move &quot;Right&quot; over &quot;over&quot;</span>
<a name="396"><span class="lineNum">     396 </span><span class="lineCov">         88 :       Token_List.Next_Token (Right); -- move &quot;Right&quot; over the layer</span></a>
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span><span class="lineCov">        176 :       declare</span>
<span class="lineNum">     399 </span><span class="lineCov">         88 :          use Ada.Strings.Unbounded;</span>
<span class="lineNum">     400 </span><span class="lineCov">        352 :          Using : constant String := To_String (Identifiers.Instance (Token_List.Token_Handle (Left).all).Identifier);</span>
<span class="lineNum">     401 </span><span class="lineCov">        352 :          Used  : constant String := To_String (Identifiers.Instance (Token_List.Token_Handle (Right).all).Identifier);</span>
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :       begin
<span class="lineNum">     404 </span><span class="lineCov">         88 :          if Settings.List_Rules then</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :             Put_Line (GNU_Prefix (File   =&gt; Settings.Rules_File_Name,</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :                                   Line   =&gt; Analyzer.Line,</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :                                   Column =&gt; Analyzer.Column)</span>
<a name="408"><span class="lineNum">     408 </span><span class="lineNoCov">          0 :                       &amp; &quot;Layer &quot; &amp; Using &amp; &quot; is over layer &quot; &amp; Used);</span></a>
<span class="lineNum">     409 </span>            :          end if;
<span class="lineNum">     410 </span><span class="lineCov">        528 :          Layers.Add_Layer ((Using_Layer =&gt; To_Unbounded_String (Using),</span>
<span class="lineNum">     411 </span><span class="lineCov">        264 :                             Used_Layer  =&gt; To_Unbounded_String (Used)));</span>
<span class="lineNum">     412 </span><span class="lineCov">        176 :       end;</span>
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span><span class="lineCov">         88 :    end Store_Layer_Declaration;</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     417 </span>            :    -- Procedure: Store_Use_Declaration
<span class="lineNum">     418 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :    procedure Store_Use_Declaration (New_Token : out Nonterminal.Class;</span>
<span class="lineNum">     420 </span>            :                                     Source    : in  Token_List.Instance'Class;
<span class="lineNum">     421 </span>            :                                     To_ID     : in  Master_Token.Token_ID)
<span class="lineNum">     422 </span>            :    is
<span class="lineNum">     423 </span>            :       pragma Unreferenced (New_Token, To_ID);
<span class="lineNum">     424 </span><span class="lineNoCov">          0 :       Left  : constant Token_List.List_Iterator := Token_List.Initial_Iterator (Source);</span>
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :       Right :          Token_List.List_Iterator := Token_List.Initial_Iterator (Source);</span>
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span>            :       use Archicheck.IO;
<span class="lineNum">     428 </span>            :       use OpenToken.Buffers;
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            :    begin
<span class="lineNum">     431 </span><span class="lineNoCov">          0 :       Token_List.Next_Token (Right); -- move &quot;Right&quot; over &quot;use&quot;</span>
<a name="432"><span class="lineNum">     432 </span><span class="lineNoCov">          0 :       Token_List.Next_Token (Right); -- move &quot;Right&quot; over &quot;component2&quot;</span></a>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :       declare</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :          use Ada.Strings.Unbounded;</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :          Using : constant String := To_String (Identifiers.Instance (Token_List.Token_Handle (Left).all).Identifier);</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :          Used  : constant String := To_String (Identifiers.Instance (Token_List.Token_Handle (Right).all).Identifier);</span>
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            :       begin
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :          if Settings.List_Rules then</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :             Put_Line (GNU_Prefix (File   =&gt; Settings.Rules_File_Name,</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :                                   Line   =&gt; Analyzer.Line,</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :                                   Column =&gt; Analyzer.Column)</span>
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :                       &amp; &quot;Component &quot; &amp; Using &amp; &quot; uses component &quot; &amp; Used);</span>
<span class="lineNum">     445 </span>            :          end if;
<span class="lineNum">     446 </span>            : --           Layers.Add_Layer ((Using_Layer =&gt; To_Unbounded_String (Using),
<span class="lineNum">     447 </span>            : --                              Used_Layer  =&gt; To_Unbounded_String (Used)));
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :       end;</span>
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :    end Store_Use_Declaration;</span>
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     453 </span>            :    -- Procedure: Store_Use_Restriction_Declaration
<span class="lineNum">     454 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :    procedure Store_Use_Restriction_Declaration (New_Token : out Nonterminal.Class;</span>
<span class="lineNum">     456 </span>            :                                                 Source    : in  Token_List.Instance'Class;
<span class="lineNum">     457 </span>            :                                                 To_ID     : in  Master_Token.Token_ID)
<span class="lineNum">     458 </span>            :    is
<span class="lineNum">     459 </span>            :       pragma Unreferenced (New_Token, To_ID);
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :       Left  : Token_List.List_Iterator := Token_List.Initial_Iterator (Source);</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :       Right : Token_List.List_Iterator := Token_List.Initial_Iterator (Source);</span>
<span class="lineNum">     462 </span>            : 
<span class="lineNum">     463 </span>            :       use Archicheck.IO;
<span class="lineNum">     464 </span>            :       use OpenToken.Buffers;
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :    begin
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :       Token_List.Next_Token (Left); -- move &quot;Left&quot; over &quot;component1&quot;</span>
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :       Token_List.Next_Token (Right); -- move &quot;Right&quot; over &quot;component1&quot;</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :       Token_List.Next_Token (Right); -- move &quot;Right&quot; over &quot;may&quot;</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :       Token_List.Next_Token (Right); -- move &quot;Right&quot; over &quot;use&quot;</span>
<a name="472"><span class="lineNum">     472 </span><span class="lineNoCov">          0 :       Token_List.Next_Token (Right); -- move &quot;Right&quot; over &quot;compoenent 2&quot;</span></a>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :       declare</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :          use Ada.Strings.Unbounded;</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :          Using : constant String := To_String (Identifiers.Instance (Token_List.Token_Handle (Left).all).Identifier);</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :          Used  : constant String := To_String (Identifiers.Instance (Token_List.Token_Handle (Right).all).Identifier);</span>
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span>            :       begin
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :          if Settings.List_Rules then</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :             Put_Line (GNU_Prefix (File   =&gt; Settings.Rules_File_Name,</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :                                   Line   =&gt; Analyzer.Line,</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :                                   Column =&gt; Analyzer.Column)</span>
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :                       &amp; &quot;component &quot; &amp; Using &amp; &quot; may use component &quot; &amp; Used);</span>
<span class="lineNum">     485 </span>            :          end if;
<span class="lineNum">     486 </span>            : --           Layers.Add_Layer ((Using_Layer =&gt; To_Unbounded_String (Using),
<span class="lineNum">     487 </span>            : --                              Used_Layer  =&gt; To_Unbounded_String (Used)));
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :       end;</span>
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :    end Store_Use_Restriction_Declaration;</span>
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span>            :    -- -------------------------------------------------------------------------
<a name="493"><span class="lineNum">     493 </span>            :    -- Procedure: Append_Unit_To_List</a>
<span class="lineNum">     494 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     495 </span><span class="lineCov">        272 :    procedure Initialize_Unit_List (New_Token : out Nonterminal.Class;</span>
<span class="lineNum">     496 </span>            :                                    Source    : in  Token_List.Instance'Class;
<span class="lineNum">     497 </span>            :                                    To_ID     : in  Master_Token.Token_ID) is
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :       pragma Unreferenced (New_Token, To_ID);</span>
<span class="lineNum">     499 </span><span class="lineCov">        136 :       Left  : constant Token_List.List_Iterator := Token_List.Initial_Iterator (Source);</span>
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            :       use Archicheck.IO;
<span class="lineNum">     502 </span>            :       use OpenToken.Buffers;
<span class="lineNum">     503 </span>            :       use Ada.Strings.Unbounded;
<span class="lineNum">     504 </span><span class="lineCov">        544 :       Unit_Name : constant String := To_String (Identifiers.Instance (Token_List.Token_Handle (Left).all).Identifier);</span>
<span class="lineNum">     505 </span><span class="lineCov">        136 :       Prefix    : constant String := GNU_Prefix (File   =&gt; Settings.Rules_File_Name,</span>
<span class="lineNum">     506 </span><span class="lineCov">        136 :                                                  Line   =&gt; Rules_File_Parser.Line,</span>
<span class="lineNum">     507 </span><span class="lineCov">        136 :                                                  Column =&gt; Rules_File_Parser.Column);</span>
<a name="508"><span class="lineNum">     508 </span>            :    begin</a>
<span class="lineNum">     509 </span><span class="lineCov">        136 :       Units := Unit_Lists.Empty_List;</span>
<span class="lineNum">     510 </span><span class="lineCov">        272 :       Unit_Lists.Append (Units, To_Unbounded_String (Unit_Name));</span>
<span class="lineNum">     511 </span><span class="lineCov">        136 :       Put_Debug_Line (Prefix &amp; &quot;Initialize_Unit_List with &quot; &amp; Unit_Name);</span>
<span class="lineNum">     512 </span><span class="lineCov">        136 :    end Initialize_Unit_List;</span>
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            :    -- -------------------------------------------------------------------------
<a name="515"><span class="lineNum">     515 </span>            :    -- Procedure: Append_Unit_To_List</a>
<span class="lineNum">     516 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     517 </span><span class="lineCov">        256 :    procedure Append_Unit_To_List (New_Token : out Nonterminal.Class;</span>
<span class="lineNum">     518 </span>            :                                   Source    : in  Token_List.Instance'Class;
<span class="lineNum">     519 </span>            :                                   To_ID     : in  Master_Token.Token_ID) is
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :       pragma Unreferenced (New_Token, To_ID);</span>
<span class="lineNum">     521 </span><span class="lineCov">        128 :       Left  : constant Token_List.List_Iterator := Token_List.Initial_Iterator (Source);</span>
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            :       use Archicheck.IO;
<span class="lineNum">     524 </span>            :       use OpenToken.Buffers;
<span class="lineNum">     525 </span>            :       use Ada.Strings.Unbounded;
<span class="lineNum">     526 </span><span class="lineCov">        512 :       Unit_Name : constant String := To_String (Identifiers.Instance (Token_List.Token_Handle (Left).all).Identifier);</span>
<span class="lineNum">     527 </span><span class="lineCov">        128 :       Prefix    : constant String := GNU_Prefix (File   =&gt; Settings.Rules_File_Name,</span>
<span class="lineNum">     528 </span><span class="lineCov">        128 :                                                  Line   =&gt; Rules_File_Parser.Line,</span>
<a name="529"><span class="lineNum">     529 </span><span class="lineCov">        128 :                                                  Column =&gt; Rules_File_Parser.Column);</span></a>
<span class="lineNum">     530 </span>            :    begin
<span class="lineNum">     531 </span><span class="lineCov">        256 :       Unit_Lists.Append (Units, To_Unbounded_String (Unit_Name));</span>
<span class="lineNum">     532 </span><span class="lineCov">        128 :       Put_Debug_Line (Prefix &amp; &quot;Append_Unit &quot; &amp; Unit_Name &amp; &quot; To_List&quot;);</span>
<span class="lineNum">     533 </span><span class="lineCov">        128 :    end Append_Unit_To_List;</span>
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span>            :    -- -------------------------------------------------------------------------
<a name="536"><span class="lineNum">     536 </span>            :    -- Procedure: Parse</a>
<span class="lineNum">     537 </span>            :    -- -------------------------------------------------------------------------
<span class="lineNum">     538 </span><span class="lineCov">         88 :    procedure Parse (File_Name  : in String) is</span>
<span class="lineNum">     539 </span>            :       use Ada.Text_IO;
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span>            :    begin
<span class="lineNum">     542 </span><span class="lineCov">         88 :       Open (Input_File,</span>
<span class="lineNum">     543 </span>            :             Mode =&gt; In_File,
<span class="lineNum">     544 </span>            :             Name =&gt; File_Name);
<span class="lineNum">     545 </span><span class="lineCov">         88 :       Set_Input (Input_File);</span>
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            :       -- LALR_Parser.Print_Table (Test_Parser);
<span class="lineNum">     548 </span>            :       Parsing : begin
<span class="lineNum">     549 </span><span class="lineCov">         88 :          if Settings.Debug_Mode then OpenToken.Trace_Parse := 0; end if; -- value &gt; 0 : debug level</span>
<span class="lineNum">     550 </span><span class="lineCov">         88 :          LALR_Parser.Parse (Rules_File_Parser);</span>
<span class="lineNum">     551 </span>            : 
<a name="552"><span class="lineNum">     552 </span>            :       exception</a>
<a name="553"><span class="lineNum">     553 </span><span class="lineCov">         24 :          when Error : others =&gt;</span></a>
<span class="lineNum">     554 </span><span class="lineCov">         24 :             IO.Put_Error (IO.GNU_Prefix (File_Name, Analyzer.Line, Analyzer.Column) &amp; &quot;parse exception&quot;);</span>
<span class="lineNum">     555 </span><span class="lineCov">         24 :             IO.Put_Error (Ada.Exceptions.Exception_Information (Error));</span>
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            :             -- Peut-on faire mieux comme message? comme par exemple :
<span class="lineNum">     558 </span>            : --              declare
<span class="lineNum">     559 </span>            : --                 ID     : constant String := Token.Name (Current_Token.all);
<span class="lineNum">     560 </span>            : --                 Lexeme : constant String := Parser.Analyzer.Lexeme;
<span class="lineNum">     561 </span>            : --
<span class="lineNum">     562 </span>            : --                 --  FIXME: merge expecting from all active parsers
<span class="lineNum">     563 </span>            : --                 Expecting_Tokens : constant Token_Array := Expecting (Parser.Table, Parsers.First.Peek.State);
<span class="lineNum">     564 </span>            : --              begin
<span class="lineNum">     565 </span>            : --                 --  FIXME: free everything
<span class="lineNum">     566 </span>            : --                 raise Syntax_Error with
<span class="lineNum">     567 </span>            : --                 Int_Image (Parser.Analyzer.Line) &amp; &quot;:&quot; &amp; Int_Image (Parser.Analyzer.Column) &amp;
<span class="lineNum">     568 </span>            : --                   &quot;: Syntax error; expecting &quot; &amp; Names (Parser.Analyzer, Expecting_Tokens) &amp;
<span class="lineNum">     569 </span>            : --                   &quot;; found &quot; &amp; ID &amp; &quot; '&quot; &amp; Lexeme &amp; &quot;'&quot;;
<span class="lineNum">     570 </span>            : --              end;
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            :       end Parsing;
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span><span class="lineCov">         88 :       Close (File =&gt; Input_File);</span>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineCov">         88 :    end Parse;</span>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineCov">        224 : end Archicheck.Rules_Parser;</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
